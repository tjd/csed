Values and Types

In Haskell, there are values and there are types. For example:

       Value      Its Type

       5          Integer  
       'a'        Char
       inc        Integer -> Integer
       [1, 2, 3]  [Integer]
       ('b', 4)   (Char, Integer)

The type's on the right are called "typings", or "type expressions",
or sometimes "type signatures". These are only a few of the
pre-defined Haskell types: there are many others, plus Haskell makes
it easy for user's to define their own types.

Haskell lets you say within the language itself that a value has a
particular type by using the "::" operator, which is read "has type":


       5 :: Integer  
       'a' :: Char
       inc :: Integer -> Integer
       [1, 2, 3] :: [Integer]
       ('b', 4) :: (Char, Integer)

Expressions like the above appear frequently in Haskell, and they
help you write programs that have no errors.

In the Haskell interpreter, you can ask to see the type of a value
using the ':t' command:

      Main> :t 'a'
      'a' :: Char

Now lets write the inc function, which simply adds 1 to a number:

       	inc n = n + 1

Haskell functions are written as a series of equations. Like all other
values, functions have a type in Haskell, and the type of the inc
function is written like this:

	inc :: Integer -> Integer

The type expression on the right of :: indicates that the function
(named inc) requires one Integer as input, and returns one Integer as
output. In an actual Haskell program, we would normally write it in
this order:

	inc :: Integer -> Integer
       	inc n = n + 1

We can check its type in the Haskell interpreter:

	Main> :t inc
	inc :: Integer -> Integer

We will use the notation a => b to mean "a reduces to b". For example,
inc 4 => 5, and inc (inc 4) => 6. It is sometimes useful to think of
functions in Haskell as "replacers", i.e. whenever Haskell sees an
expression of the form "inc n", it replaces it with the expression "n
+ 1". This idea of reduction is essentially the same as the notion of
"returning a value" that often used in other programming
languages. Having an explicit notation for reduction will prove quite
handy. (Aside: Notice that we write "inc 4" with no brackets. Most
other programming languages follow the convention in mathematics and
write "inc(4)". Haskell's way saves you some typing, but ultimately
whether this unusual syntax hurts or harms Haskell remains to be
seen. It may be that this is different enough from regular languages
that ordinary programmers will not want to learn this new way of
calling functions.)

You should ask yourself the purpose of these type expressions. Most
other languages do without them, and, in fact, you can usually leave
them out in Haskell (most of the time, Haskell can automatically infer
the types of an expression). Their value is simple: they let you write
type-safe programs, where a type-safe program has no errors caused by
type-mismatches. Haskell is able to find almost all type errors
*before* your program runs by analyzing the type statements. The great
thing is that very often once your program runs, it runs correctly
without error. Of course, only type-errors are caught, and you won't
always be writing error free programs on the first try. But being able
to automatically catch a large class of common errors is a big win.

There are two other benefits to Haskell's typing that we will mention:
type expressions often provide a useful kind of documentation, helping
to explain the input and output of complex functions. This is
especially useful in large, complex programs. A second, more
idealistic benefit, is that the type expressions are going to give you
a deeper understanding of computing, and the mathematics of
calculation. While the value of this in practice is debatable for the
average working programmer, it is a fascinating and rewarding study
that many programmers enjoy. If you ever want to design your own
programming language, then it behooves you to understand Haskell
because it so jam-packed full of cool ideas. (The designers of the
Python programming language, for example, has happily borrowed many
ideas from Haskell. Also, Java generics, which first appeared in Java
5, are an intellectual relative of similar ideas born in Haskell.)

Polymorphic Types
-----------------

The word "polymorphic" may sound intimidating, but don't worry:
polymorphic types are a straightforward and useful idea.

Consider the type expression 

	[1, 2, 3] :: [Integer]

This is read as "[1, 2, 3] has the type 'list of Integer'". The type
expression [Integer] thus means 'list of Integer', and the expression
[Char] means 'list of Char'. As you will soon see, it is very often
the case that we want to write functions that work on lists of any
kind of value, e.g. a function that counts the number of items in a
list doesn't care about the type of the actual list items. It just
counts how many items there are.

So a polymorphic type is just a way to refer to a family of related
types. For example, [a] is a polymorphic type meaning "list of values
of type a". So if we wanted to write a Haskell function that returned
the number of items in any list, its type expression would be:

	length :: [a] -> Integer

This is read as saying "the function named 'length' takes as input a
list of items all of type a, and returns an Integer".

(Aside: Haskell follows the convention of using lower-case letters to
indicate polymorphic variables, and upper-case letters to indicate
concrete types like Intger and Char.)

Lists
-----

Lets actually write the length function. To do that, we need to know
more about Haskell's list data structure. First, [] represents the
empty list, i.e. the list with no elements on it. You build lists
using the ':' operator, e.g.

	3 : [] => [3]
	2 : (3 : []) => 2 : [3] => [2, 3]
       	1 : (2 : (3 : [])) => 1 : (2 : [3])) => 1 : [2, 3] => [1, 2, 3]

An important restrictions on Haskell lists is that they must contain
elements that are of the same type. For example, [1, 'a'] is illegal
in Haskell because 1 and 'a' are different types (or, to be more
precise, there is no type in Haskell that has both 1 and 'a' as
values). This is interesting restriction: why should a list not be
able to contain values of different types? The answer is deep, and
here we can only hint at it: the automatic type checking does not work
if lists can have items of different types. (Aside: Some languages,
like Python, do allow lists to have items with different types, and
these can be quite handy. But alas, Python is not able to do anywhere
near the same amount of type error-checking that Haskell can do.)

With this basic introduction to lists, we can now write a function to
calculate the length of any Haskell list:

	mylength :: [a] -> Integer
	mylength []           =  0
	mylength (first:rest) =  1 + mylength rest

(Aside: We call this "mylength" instead of "length" because Haskell
usually starts with a pre-defined function called "length".)

This function is called 'mylength', and it consists of three lines:

   - The first line is the type signature for the function, and it
     says that the mylength function takes a list of values of type a
     as input, and returns a single Integer as output

   - The second line is an equation that deals with a single case: the
     case when the list is empty. An empty list has no elements, and
     so its length is 0.

   - The third line is an equation that handles lists with 1 or more
     values on them. The notation first:rest is quite handy: the
     variable first refers to the first item of the list, and the
     variable rest refers to the list consisting of the rest of the
     items except for the first. So for example, if the list was [1,
     2, 3, 4], then first would be the Integer 1, and rest would be
     the list [2, 3, 4]. On the right-hand side of the =, we see the
     expression 1 + mylength rest, and you can guess what this does:
     mylength rest calculates the length of the "rest" part of the
     list (everything but the first value), and the 1 is added to that
     to give the final result. This is a "recursive" function, meaning
     that it calls itself.

With this function created, we can now calculate values. For example:

	   mylength [1, 2, 3]
	=> 1 + mylength [2, 3]
	=> 1 + 1 + mylength [3]
	=> 1 + 1 + 1 + mylength []
	=> 1 + 1 + 1 + 0
	=> 3

The ideas is quite simple: look at the express and equations in the
function, and match the expression to left-hand side of one of the
equations. Then replace the matched part with the part on the
right-hand side of the chosen equation. 

The length function works with lists of any type of values, e.g.:

	mylength [1, 2, 3] => 3
        mylength ['x', 'y'] => 2
        mylength [[3], [4], [5]] => 3

mylength works with all these lists because nothing in it relies on
the specific type of its values.

Functions
---------

Consider the following function for adding two Integers:

	 add :: Integer -> Integer -> Integer
	 add x y = x + y

The type expression Integer -> Integer -> Integer is read in English
as "the function takes two inputs of type Integer, and returns a
single output of type Integer". The -> arrow in the notation
associates to the right, meaning Integer -> Integer -> Integer is a
short form of Integer -> (Integer -> Integer). The bracketed form
suggests that only one Integer input is take, and a function that
takes an returns an Integer is returned. Indeed, this is often a
useful way to think about functions because it not only simplifies
them (i.e. you only ever have to consider functions that take a single
input), but it can be handy for quickly creating other functions.

For example, you can use add in the creation of other functions, e.g.:

    inc = add 1

Think about this! Something very interesting and useful occurs in this
definition. The add function we've just defined takes *two* Integers
as inputs, but in this equation we've only given add a single
input. In most programming languages, this illegal and causes an
error. But not in Haskell. The expression add 1 evaluates to a new
function that takes a single Integer input and returns a single
Integer output. Look again at the types of add and inc, where the type
of inc has been spaced in a suggestive way:

    inc ::            Integer -> Integer
    add :: Integer -> Integer -> Integer

Following the arrow notation, you can see that add 1 ought to evaluate
to an expression with the type Integer -> Integer --- exactly the type
of inc. Indeed, add 1 evaluates to a function of type Integer ->
Integer, which takes a single Integer input and returns a single
Integer output that is one more than the input. Precisely the
definition of inc!

You certainly could have written inc like this:

    inc :: Integer -> Integer
    inc x = add x 1

But "inc = add 1" is far simpler to read and write.



